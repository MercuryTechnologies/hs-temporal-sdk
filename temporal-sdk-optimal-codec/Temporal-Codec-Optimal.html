<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Temporal.Codec.Optimal</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">temporal-sdk-optimal-codec</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Temporal.Codec.Optimal.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Temporal.Codec.Optimal</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:defaultCodec">defaultCodec</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> '[<a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Null" title="Temporal.Payload">Null</a>, <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Binary" title="Temporal.Payload">Binary</a>, <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Protobuf" title="Temporal.Payload">Protobuf</a>, <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:JSON" title="Temporal.Payload">JSON</a>]</li><li class="src short"><span class="keyword">data</span> <a href="#t:Composite">Composite</a> (codecs :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>]) <span class="keyword">where</span><ul class="subs"><li><a href="#v:CompositeNil">CompositeNil</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> ('[] :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>])</li><li><a href="#v:CompositeCons">CompositeCons</a> :: <span class="keyword">forall</span> codec (codecs1 :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>]). codec -&gt; <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> codecs1 -&gt; <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> (codec ': codecs1)</li></ul></li><li class="src short"><span class="keyword">class</span> c <a href="#t:-124--124-">||</a> d <span class="keyword">where</span><ul class="subs"><li><a href="#v:dispatch">dispatch</a> :: ((<a href="Temporal-Codec-Optimal.html#t:IsSat" title="Temporal.Codec.Optimal">IsSat</a> c <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a>, c) =&gt; r) -&gt; ((<a href="Temporal-Codec-Optimal.html#t:IsSat" title="Temporal.Codec.Optimal">IsSat</a> c <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>, <a href="Temporal-Codec-Optimal.html#t:IsSat" title="Temporal.Codec.Optimal">IsSat</a> d <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a>, d) =&gt; r) -&gt; r</li></ul></li><li class="src short"><a href="#v:ifSat">ifSat</a> :: <a href="Temporal-Codec-Optimal.html#t:IfSat" title="Temporal.Codec.Optimal">IfSat</a> ct =&gt; ((<a href="Temporal-Codec-Optimal.html#t:IsSat" title="Temporal.Codec.Optimal">IsSat</a> ct <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a>, ct) =&gt; r) -&gt; (<a href="Temporal-Codec-Optimal.html#t:IsSat" title="Temporal.Codec.Optimal">IsSat</a> ct <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a> =&gt; r) -&gt; r</li><li class="src short"><span class="keyword">type</span> <a href="#t:IfSat">IfSat</a> ct = ct <a href="Temporal-Codec-Optimal.html#t:-124--124-" title="Temporal.Codec.Optimal">||</a> ()</li><li class="src short"><span class="keyword">type family</span> <a href="#t:IsSat">IsSat</a> ct :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <span class="keyword">where ...</span></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:defaultCodec" class="def">defaultCodec</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> '[<a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Null" title="Temporal.Payload">Null</a>, <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Binary" title="Temporal.Payload">Binary</a>, <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Protobuf" title="Temporal.Payload">Protobuf</a>, <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:JSON" title="Temporal.Payload">JSON</a>] <a href="src/Temporal.Codec.Optimal.html#defaultCodec" class="link">Source</a> <a href="#v:defaultCodec" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Composite" class="def">Composite</a> (codecs :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>]) <span class="keyword">where</span> <a href="src/Temporal.Codec.Optimal.html#Composite" class="link">Source</a> <a href="#t:Composite" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a></code> codec allows you to combine multiple codecs into one.</p><p>The codecs are tried in order, and the first one that succeeds is used.
If none of the codecs succeed, the compile-time error message will indicate
the type that didn't satisfy any of the specified codecs.</p><p>This Codec is useful when you want to support multiple serialization formats
and choose the best / most performant one for each type.</p><p>Note that this Codec relies upon the 'if-instance' package, which supplies
a compiler plugin that allows us to use this. You must add the following
pragma to the module that registers your workflow code:</p><pre>{\-# OPTIONS_GHC -fplugin=IfSat.Plugin #-\}
-- ^ Put this at the top of the module that registers your workflow code.

let testFn :: Int -&gt; Text -&gt; Bool -&gt; W.Workflow () () (Int, Text, Bool)
    testFn a b c = pure (a, b, c)
    wf = W.provideWorkflow defaultCodec &quot;test&quot; () testFn
    conf = configure () () $ do
      addWorkflow wf</pre><p>If you forget to add this pragma, your code will fail to compile with
a message like:</p><pre> hs-temporal/test/IntegrationSpec.hs:66:16: error:
    &#8226; No instance for (Codec Null ()
                       Data.Constraint.If.|| Codec
                                               (Temporal.Payload.Composite
                                                  '[Binary, Protobuf, JSON])
                                               ())
        arising from a use of &#8216;W.provideWorkflow&#8217;
    &#8226; In the expression:
        W.provideWorkflow defaultCodec &quot;test&quot; () testFn
      In an equation for &#8216;wf&#8217;:
          wf = W.provideWorkflow defaultCodec &quot;test&quot; () testFn
      In the expression:
        do taskQueue &lt;- W.TaskQueue &lt;$&gt; uuidText
           let testFn :: W.Workflow () () ()
               testFn = pure ()
               ....
           withWorker conf
             $ do wfId &lt;- uuidText
                  let ...
                  ....
   |
66 |           wf = W.provideWorkflow defaultCodec &quot;test&quot; () testFn
   |                ^^^^^^^^^^^^^^^^^</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:CompositeNil" class="def">CompositeNil</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> ('[] :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>])</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:CompositeCons" class="def">CompositeCons</a> :: <span class="keyword">forall</span> codec (codecs1 :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>]). codec -&gt; <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> codecs1 -&gt; <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> (codec ': codecs1)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Composite">Instances</h4><details id="i:Composite" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Composite:Codec:1"></span> <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Codec" title="Temporal.Payload">Codec</a> fmt a <a href="Temporal-Codec-Optimal.html#t:-124--124-" title="Temporal.Codec.Optimal">||</a> <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Codec" title="Temporal.Payload">Codec</a> (<a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> codecs) a =&gt; <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Codec" title="Temporal.Payload">Codec</a> (<a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> (fmt ': codecs)) a</span> <a href="src/Temporal.Codec.Optimal.html#line-78" class="link">Source</a> <a href="#t:Composite" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Composite:Codec:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Temporal-Codec-Optimal.html">Temporal.Codec.Optimal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:encoding">encoding</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> (fmt ': codecs) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> a -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.12.1.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="#v:encoding" class="selflink">#</a></p><p class="src"><a href="#v:messageType">messageType</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> (fmt ': codecs) -&gt; a -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.12.1.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="#v:messageType" class="selflink">#</a></p><p class="src"><a href="#v:encode">encode</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> (fmt ': codecs) -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Payload" title="Temporal.Payload">Payload</a> <a href="#v:encode" class="selflink">#</a></p><p class="src"><a href="#v:decode">decode</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> (fmt ': codecs) -&gt; <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Payload" title="Temporal.Payload">Payload</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> a) <a href="#v:decode" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Composite:Codec:2"></span> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/GHC-TypeLits.html#t:TypeError" title="GHC.TypeLits">TypeError</a> ('<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/GHC-TypeLits.html#v:ShowType" title="GHC.TypeLits">ShowType</a> a '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/GHC-TypeLits.html#v::-60--62-:" title="GHC.TypeLits">:&lt;&gt;:</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/GHC-TypeLits.html#v:Text" title="GHC.TypeLits">Text</a> &quot; is not supported by any of the provided codecs&quot;) :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) =&gt; <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Codec" title="Temporal.Payload">Codec</a> (<a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> ('[] :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>])) a</span> <a href="src/Temporal.Codec.Optimal.html#line-71" class="link">Source</a> <a href="#t:Composite" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Composite:Codec:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Temporal-Codec-Optimal.html">Temporal.Codec.Optimal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:encoding">encoding</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> ('[] :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>]) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> a -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.12.1.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="#v:encoding" class="selflink">#</a></p><p class="src"><a href="#v:messageType">messageType</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> ('[] :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>]) -&gt; a -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.12.1.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="#v:messageType" class="selflink">#</a></p><p class="src"><a href="#v:encode">encode</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> ('[] :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>]) -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Payload" title="Temporal.Payload">Payload</a> <a href="#v:encode" class="selflink">#</a></p><p class="src"><a href="#v:decode">decode</a> :: <a href="Temporal-Codec-Optimal.html#t:Composite" title="Temporal.Codec.Optimal">Composite</a> ('[] :: [<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>]) -&gt; <a href="https://hackage.haskell.org/package/temporal-sdk-0.0.1.0/docs/Temporal-Payload.html#t:Payload" title="Temporal.Payload">Payload</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> a) <a href="#v:decode" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">class</span> c <a id="t:-124--124-" class="def">||</a> d <span class="keyword">where</span> <a href="#t:-124--124-" class="selflink">#</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:dispatch" class="def">dispatch</a> :: ((<a href="Temporal-Codec-Optimal.html#t:IsSat" title="Temporal.Codec.Optimal">IsSat</a> c <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a>, c) =&gt; r) -&gt; ((<a href="Temporal-Codec-Optimal.html#t:IsSat" title="Temporal.Codec.Optimal">IsSat</a> c <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>, <a href="Temporal-Codec-Optimal.html#t:IsSat" title="Temporal.Codec.Optimal">IsSat</a> d <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a>, d) =&gt; r) -&gt; r <a href="#v:dispatch" class="selflink">#</a></p></div></div><div class="top"><p class="src"><a id="v:ifSat" class="def">ifSat</a> :: <a href="Temporal-Codec-Optimal.html#t:IfSat" title="Temporal.Codec.Optimal">IfSat</a> ct =&gt; ((<a href="Temporal-Codec-Optimal.html#t:IsSat" title="Temporal.Codec.Optimal">IsSat</a> ct <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a>, ct) =&gt; r) -&gt; (<a href="Temporal-Codec-Optimal.html#t:IsSat" title="Temporal.Codec.Optimal">IsSat</a> ct <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a> =&gt; r) -&gt; r <a href="#v:ifSat" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:IfSat" class="def">IfSat</a> ct = ct <a href="Temporal-Codec-Optimal.html#t:-124--124-" title="Temporal.Codec.Optimal">||</a> () <a href="#t:IfSat" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type family</span> <a id="t:IsSat" class="def">IsSat</a> ct :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <span class="keyword">where ...</span> <a href="#t:IsSat" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.28.0</p></div></body></html>