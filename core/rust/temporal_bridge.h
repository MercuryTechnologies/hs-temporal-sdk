/* Generated with cbindgen:0.26.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

enum WorkerErrorCode {
  SDKError = 1,
  InitWorkerFailed = 2,
  InitReplayWorkerFailed = 3,
  InvalidProto = 4,
  ReplayWorkerClosed = 5,
  PollShutdownError = 6,
  PollFailure = 7,
  CompletionFailure = 8,
  InvalidWorkerConfig = 9,
};
typedef uint8_t WorkerErrorCode;

typedef struct ClientRef ClientRef;

typedef struct EphemeralServerRef EphemeralServerRef;

typedef struct HistoryPusher HistoryPusher;

typedef struct RuntimeRef RuntimeRef;

typedef struct WorkerRef WorkerRef;

/**
 * A utility type to represent arrays of the parametrized type.
 * Note that the parametrized type should have a C-compatible representation.
 *
 * # Example
 *
 * ```
 * use ffi_convert::{CReprOf, AsRust, CDrop, CArray};
 * use libc::c_char;
 *
 * pub struct PizzaTopping {
 *     pub ingredient: String,
 * }
 *
 * #[derive(CDrop, CReprOf, AsRust)]
 * #[target_type(PizzaTopping)]
 * pub struct CPizzaTopping {
 *     pub ingredient: *const c_char
 * }
 *
 * let toppings = vec![
 *         PizzaTopping { ingredient: "Cheese".to_string() },
 *         PizzaTopping { ingredient: "Ham".to_string() } ];
 *
 * let ctoppings = CArray::<CPizzaTopping>::c_repr_of(toppings);
 *
 * ```
 */
typedef struct CArray_u8 {
  const uint8_t *data_ptr;
  uintptr_t size;
} CArray_u8;

typedef struct Capability {
  int cap_num;
} Capability;

typedef struct MVar {
  uint8_t _data[0];
} MVar;

/**
 * A utility type to represent arrays of the parametrized type.
 * Note that the parametrized type should have a C-compatible representation.
 *
 * # Example
 *
 * ```
 * use ffi_convert::{CReprOf, AsRust, CDrop, CArray};
 * use libc::c_char;
 *
 * pub struct PizzaTopping {
 *     pub ingredient: String,
 * }
 *
 * #[derive(CDrop, CReprOf, AsRust)]
 * #[target_type(PizzaTopping)]
 * pub struct CPizzaTopping {
 *     pub ingredient: *const c_char
 * }
 *
 * let toppings = vec![
 *         PizzaTopping { ingredient: "Cheese".to_string() },
 *         PizzaTopping { ingredient: "Ham".to_string() } ];
 *
 * let ctoppings = CArray::<CPizzaTopping>::c_repr_of(toppings);
 *
 * ```
 */
typedef struct CArray_CArray_u8 {
  const struct CArray_u8 *data_ptr;
  uintptr_t size;
} CArray_CArray_u8;

typedef struct CRPCError {
  uint32_t code;
  const char *message;
  const struct CArray_u8 *details;
} CRPCError;

typedef struct HaskellHashMapEntries {
  const uint8_t *key;
  uintptr_t key_len;
  const uint8_t *value;
  uintptr_t value_len;
  const struct HaskellHashMapEntries *next;
} HaskellHashMapEntries;

typedef struct RpcCall {
  const struct CArray_u8 *req;
  bool retry;
  const struct HaskellHashMapEntries *metadata;
  const uint64_t *timeout_millis;
} RpcCall;

typedef struct CWorkerError {
  WorkerErrorCode code;
  const char *message;
} CWorkerError;

typedef struct CUnit {

} CUnit;

struct RuntimeRef *hs_temporal_init_runtime(const struct CArray_u8 *telemetry_opts,
                                            void (*try_put_mvar)(struct Capability, struct MVar*));

void hs_temporal_free_runtime(struct RuntimeRef *runtime);

void hs_temporal_drop_byte_array(const struct CArray_u8 *str);

const struct CArray_CArray_u8 *hs_temporal_runtime_fetch_logs(struct RuntimeRef *runtime);

void hs_temporal_runtime_free_logs(const struct CArray_CArray_u8 *logs);

void hs_temporal_connect_client(const struct RuntimeRef *runtime_ref,
                                const char *config_json,
                                struct MVar *mvar,
                                struct Capability cap,
                                struct CArray_u8 **error_slot,
                                struct ClientRef **result_slot);

void hs_temporal_drop_client(struct ClientRef *client);

void hs_temporal_drop_rpc_error(struct CRPCError *error);

void hs_count_workflow_executions(struct ClientRef *client,
                                  const struct RpcCall *c_call,
                                  struct MVar *mvar,
                                  struct Capability cap,
                                  struct CRPCError **error_slot,
                                  struct CArray_u8 **result_slot);

void hs_create_schedule(struct ClientRef *client,
                        const struct RpcCall *c_call,
                        struct MVar *mvar,
                        struct Capability cap,
                        struct CRPCError **error_slot,
                        struct CArray_u8 **result_slot);

void hs_delete_schedule(struct ClientRef *client,
                        const struct RpcCall *c_call,
                        struct MVar *mvar,
                        struct Capability cap,
                        struct CRPCError **error_slot,
                        struct CArray_u8 **result_slot);

void hs_deprecate_namespace(struct ClientRef *client,
                            const struct RpcCall *c_call,
                            struct MVar *mvar,
                            struct Capability cap,
                            struct CRPCError **error_slot,
                            struct CArray_u8 **result_slot);

void hs_describe_namespace(struct ClientRef *client,
                           const struct RpcCall *c_call,
                           struct MVar *mvar,
                           struct Capability cap,
                           struct CRPCError **error_slot,
                           struct CArray_u8 **result_slot);

void hs_describe_schedule(struct ClientRef *client,
                          const struct RpcCall *c_call,
                          struct MVar *mvar,
                          struct Capability cap,
                          struct CRPCError **error_slot,
                          struct CArray_u8 **result_slot);

void hs_describe_task_queue(struct ClientRef *client,
                            const struct RpcCall *c_call,
                            struct MVar *mvar,
                            struct Capability cap,
                            struct CRPCError **error_slot,
                            struct CArray_u8 **result_slot);

void hs_describe_workflow_execution(struct ClientRef *client,
                                    const struct RpcCall *c_call,
                                    struct MVar *mvar,
                                    struct Capability cap,
                                    struct CRPCError **error_slot,
                                    struct CArray_u8 **result_slot);

void hs_get_cluster_info(struct ClientRef *client,
                         const struct RpcCall *c_call,
                         struct MVar *mvar,
                         struct Capability cap,
                         struct CRPCError **error_slot,
                         struct CArray_u8 **result_slot);

void hs_get_search_attributes(struct ClientRef *client,
                              const struct RpcCall *c_call,
                              struct MVar *mvar,
                              struct Capability cap,
                              struct CRPCError **error_slot,
                              struct CArray_u8 **result_slot);

void hs_get_system_info(struct ClientRef *client,
                        const struct RpcCall *c_call,
                        struct MVar *mvar,
                        struct Capability cap,
                        struct CRPCError **error_slot,
                        struct CArray_u8 **result_slot);

void hs_get_worker_build_id_compatibility(struct ClientRef *client,
                                          const struct RpcCall *c_call,
                                          struct MVar *mvar,
                                          struct Capability cap,
                                          struct CRPCError **error_slot,
                                          struct CArray_u8 **result_slot);

void hs_get_workflow_execution_history(struct ClientRef *client,
                                       const struct RpcCall *c_call,
                                       struct MVar *mvar,
                                       struct Capability cap,
                                       struct CRPCError **error_slot,
                                       struct CArray_u8 **result_slot);

void hs_get_workflow_execution_history_reverse(struct ClientRef *client,
                                               const struct RpcCall *c_call,
                                               struct MVar *mvar,
                                               struct Capability cap,
                                               struct CRPCError **error_slot,
                                               struct CArray_u8 **result_slot);

void hs_list_archived_workflow_executions(struct ClientRef *client,
                                          const struct RpcCall *c_call,
                                          struct MVar *mvar,
                                          struct Capability cap,
                                          struct CRPCError **error_slot,
                                          struct CArray_u8 **result_slot);

void hs_list_closed_workflow_executions(struct ClientRef *client,
                                        const struct RpcCall *c_call,
                                        struct MVar *mvar,
                                        struct Capability cap,
                                        struct CRPCError **error_slot,
                                        struct CArray_u8 **result_slot);

void hs_list_namespaces(struct ClientRef *client,
                        const struct RpcCall *c_call,
                        struct MVar *mvar,
                        struct Capability cap,
                        struct CRPCError **error_slot,
                        struct CArray_u8 **result_slot);

void hs_list_open_workflow_executions(struct ClientRef *client,
                                      const struct RpcCall *c_call,
                                      struct MVar *mvar,
                                      struct Capability cap,
                                      struct CRPCError **error_slot,
                                      struct CArray_u8 **result_slot);

void hs_list_schedule_matching_times(struct ClientRef *client,
                                     const struct RpcCall *c_call,
                                     struct MVar *mvar,
                                     struct Capability cap,
                                     struct CRPCError **error_slot,
                                     struct CArray_u8 **result_slot);

void hs_list_schedules(struct ClientRef *client,
                       const struct RpcCall *c_call,
                       struct MVar *mvar,
                       struct Capability cap,
                       struct CRPCError **error_slot,
                       struct CArray_u8 **result_slot);

void hs_list_task_queue_partitions(struct ClientRef *client,
                                   const struct RpcCall *c_call,
                                   struct MVar *mvar,
                                   struct Capability cap,
                                   struct CRPCError **error_slot,
                                   struct CArray_u8 **result_slot);

void hs_list_workflow_executions(struct ClientRef *client,
                                 const struct RpcCall *c_call,
                                 struct MVar *mvar,
                                 struct Capability cap,
                                 struct CRPCError **error_slot,
                                 struct CArray_u8 **result_slot);

void hs_patch_schedule(struct ClientRef *client,
                       const struct RpcCall *c_call,
                       struct MVar *mvar,
                       struct Capability cap,
                       struct CRPCError **error_slot,
                       struct CArray_u8 **result_slot);

void hs_poll_activity_task_queue(struct ClientRef *client,
                                 const struct RpcCall *c_call,
                                 struct MVar *mvar,
                                 struct Capability cap,
                                 struct CRPCError **error_slot,
                                 struct CArray_u8 **result_slot);

void hs_poll_workflow_execution_update(struct ClientRef *client,
                                       const struct RpcCall *c_call,
                                       struct MVar *mvar,
                                       struct Capability cap,
                                       struct CRPCError **error_slot,
                                       struct CArray_u8 **result_slot);

void hs_poll_workflow_task_queue(struct ClientRef *client,
                                 const struct RpcCall *c_call,
                                 struct MVar *mvar,
                                 struct Capability cap,
                                 struct CRPCError **error_slot,
                                 struct CArray_u8 **result_slot);

void hs_query_workflow(struct ClientRef *client,
                       const struct RpcCall *c_call,
                       struct MVar *mvar,
                       struct Capability cap,
                       struct CRPCError **error_slot,
                       struct CArray_u8 **result_slot);

void hs_record_activity_task_heartbeat(struct ClientRef *client,
                                       const struct RpcCall *c_call,
                                       struct MVar *mvar,
                                       struct Capability cap,
                                       struct CRPCError **error_slot,
                                       struct CArray_u8 **result_slot);

void hs_record_activity_task_heartbeat_by_id(struct ClientRef *client,
                                             const struct RpcCall *c_call,
                                             struct MVar *mvar,
                                             struct Capability cap,
                                             struct CRPCError **error_slot,
                                             struct CArray_u8 **result_slot);

void hs_register_namespace(struct ClientRef *client,
                           const struct RpcCall *c_call,
                           struct MVar *mvar,
                           struct Capability cap,
                           struct CRPCError **error_slot,
                           struct CArray_u8 **result_slot);

void hs_request_cancel_workflow_execution(struct ClientRef *client,
                                          const struct RpcCall *c_call,
                                          struct MVar *mvar,
                                          struct Capability cap,
                                          struct CRPCError **error_slot,
                                          struct CArray_u8 **result_slot);

void hs_reset_sticky_task_queue(struct ClientRef *client,
                                const struct RpcCall *c_call,
                                struct MVar *mvar,
                                struct Capability cap,
                                struct CRPCError **error_slot,
                                struct CArray_u8 **result_slot);

void hs_reset_workflow_execution(struct ClientRef *client,
                                 const struct RpcCall *c_call,
                                 struct MVar *mvar,
                                 struct Capability cap,
                                 struct CRPCError **error_slot,
                                 struct CArray_u8 **result_slot);

void hs_respond_activity_task_canceled(struct ClientRef *client,
                                       const struct RpcCall *c_call,
                                       struct MVar *mvar,
                                       struct Capability cap,
                                       struct CRPCError **error_slot,
                                       struct CArray_u8 **result_slot);

void hs_respond_activity_task_canceled_by_id(struct ClientRef *client,
                                             const struct RpcCall *c_call,
                                             struct MVar *mvar,
                                             struct Capability cap,
                                             struct CRPCError **error_slot,
                                             struct CArray_u8 **result_slot);

void hs_respond_activity_task_completed(struct ClientRef *client,
                                        const struct RpcCall *c_call,
                                        struct MVar *mvar,
                                        struct Capability cap,
                                        struct CRPCError **error_slot,
                                        struct CArray_u8 **result_slot);

void hs_respond_activity_task_completed_by_id(struct ClientRef *client,
                                              const struct RpcCall *c_call,
                                              struct MVar *mvar,
                                              struct Capability cap,
                                              struct CRPCError **error_slot,
                                              struct CArray_u8 **result_slot);

void hs_respond_activity_task_failed(struct ClientRef *client,
                                     const struct RpcCall *c_call,
                                     struct MVar *mvar,
                                     struct Capability cap,
                                     struct CRPCError **error_slot,
                                     struct CArray_u8 **result_slot);

void hs_respond_activity_task_failed_by_id(struct ClientRef *client,
                                           const struct RpcCall *c_call,
                                           struct MVar *mvar,
                                           struct Capability cap,
                                           struct CRPCError **error_slot,
                                           struct CArray_u8 **result_slot);

void hs_respond_query_task_completed(struct ClientRef *client,
                                     const struct RpcCall *c_call,
                                     struct MVar *mvar,
                                     struct Capability cap,
                                     struct CRPCError **error_slot,
                                     struct CArray_u8 **result_slot);

void hs_respond_workflow_task_completed(struct ClientRef *client,
                                        const struct RpcCall *c_call,
                                        struct MVar *mvar,
                                        struct Capability cap,
                                        struct CRPCError **error_slot,
                                        struct CArray_u8 **result_slot);

void hs_respond_workflow_task_failed(struct ClientRef *client,
                                     const struct RpcCall *c_call,
                                     struct MVar *mvar,
                                     struct Capability cap,
                                     struct CRPCError **error_slot,
                                     struct CArray_u8 **result_slot);

void hs_scan_workflow_executions(struct ClientRef *client,
                                 const struct RpcCall *c_call,
                                 struct MVar *mvar,
                                 struct Capability cap,
                                 struct CRPCError **error_slot,
                                 struct CArray_u8 **result_slot);

void hs_signal_with_start_workflow_execution(struct ClientRef *client,
                                             const struct RpcCall *c_call,
                                             struct MVar *mvar,
                                             struct Capability cap,
                                             struct CRPCError **error_slot,
                                             struct CArray_u8 **result_slot);

void hs_signal_workflow_execution(struct ClientRef *client,
                                  const struct RpcCall *c_call,
                                  struct MVar *mvar,
                                  struct Capability cap,
                                  struct CRPCError **error_slot,
                                  struct CArray_u8 **result_slot);

void hs_start_workflow_execution(struct ClientRef *client,
                                 const struct RpcCall *c_call,
                                 struct MVar *mvar,
                                 struct Capability cap,
                                 struct CRPCError **error_slot,
                                 struct CArray_u8 **result_slot);

void hs_terminate_workflow_execution(struct ClientRef *client,
                                     const struct RpcCall *c_call,
                                     struct MVar *mvar,
                                     struct Capability cap,
                                     struct CRPCError **error_slot,
                                     struct CArray_u8 **result_slot);

void hs_update_namespace(struct ClientRef *client,
                         const struct RpcCall *c_call,
                         struct MVar *mvar,
                         struct Capability cap,
                         struct CRPCError **error_slot,
                         struct CArray_u8 **result_slot);

void hs_update_schedule(struct ClientRef *client,
                        const struct RpcCall *c_call,
                        struct MVar *mvar,
                        struct Capability cap,
                        struct CRPCError **error_slot,
                        struct CArray_u8 **result_slot);

void hs_update_workflow_execution(struct ClientRef *client,
                                  const struct RpcCall *c_call,
                                  struct MVar *mvar,
                                  struct Capability cap,
                                  struct CRPCError **error_slot,
                                  struct CArray_u8 **result_slot);

void hs_update_worker_build_id_compatibility(struct ClientRef *client,
                                             const struct RpcCall *c_call,
                                             struct MVar *mvar,
                                             struct Capability cap,
                                             struct CRPCError **error_slot,
                                             struct CArray_u8 **result_slot);

void hs_get_current_time(struct ClientRef *client,
                         const struct RpcCall *c_call,
                         struct MVar *mvar,
                         struct Capability cap,
                         struct CRPCError **error_slot,
                         struct CArray_u8 **result_slot);

void hs_lock_time_skipping(struct ClientRef *client,
                           const struct RpcCall *c_call,
                           struct MVar *mvar,
                           struct Capability cap,
                           struct CRPCError **error_slot,
                           struct CArray_u8 **result_slot);

void hs_sleep_until(struct ClientRef *client,
                    const struct RpcCall *c_call,
                    struct MVar *mvar,
                    struct Capability cap,
                    struct CRPCError **error_slot,
                    struct CArray_u8 **result_slot);

void hs_sleep(struct ClientRef *client,
              const struct RpcCall *c_call,
              struct MVar *mvar,
              struct Capability cap,
              struct CRPCError **error_slot,
              struct CArray_u8 **result_slot);

void hs_unlock_time_skipping_with_sleep(struct ClientRef *client,
                                        const struct RpcCall *c_call,
                                        struct MVar *mvar,
                                        struct Capability cap,
                                        struct CRPCError **error_slot,
                                        struct CArray_u8 **result_slot);

void hs_unlock_time_skipping(struct ClientRef *client,
                             const struct RpcCall *c_call,
                             struct MVar *mvar,
                             struct Capability cap,
                             struct CRPCError **error_slot,
                             struct CArray_u8 **result_slot);

void hs_add_or_update_remote_cluster(struct ClientRef *client,
                                     const struct RpcCall *c_call,
                                     struct MVar *mvar,
                                     struct Capability cap,
                                     struct CRPCError **error_slot,
                                     struct CArray_u8 **result_slot);

void hs_add_search_attributes(struct ClientRef *client,
                              const struct RpcCall *c_call,
                              struct MVar *mvar,
                              struct Capability cap,
                              struct CRPCError **error_slot,
                              struct CArray_u8 **result_slot);

void hs_delete_namespace(struct ClientRef *client,
                         const struct RpcCall *c_call,
                         struct MVar *mvar,
                         struct Capability cap,
                         struct CRPCError **error_slot,
                         struct CArray_u8 **result_slot);

void hs_list_clusters(struct ClientRef *client,
                      const struct RpcCall *c_call,
                      struct MVar *mvar,
                      struct Capability cap,
                      struct CRPCError **error_slot,
                      struct CArray_u8 **result_slot);

void hs_list_search_attributes(struct ClientRef *client,
                               const struct RpcCall *c_call,
                               struct MVar *mvar,
                               struct Capability cap,
                               struct CRPCError **error_slot,
                               struct CArray_u8 **result_slot);

void hs_remove_remote_cluster(struct ClientRef *client,
                              const struct RpcCall *c_call,
                              struct MVar *mvar,
                              struct Capability cap,
                              struct CRPCError **error_slot,
                              struct CArray_u8 **result_slot);

void hs_remove_search_attributes(struct ClientRef *client,
                                 const struct RpcCall *c_call,
                                 struct MVar *mvar,
                                 struct Capability cap,
                                 struct CRPCError **error_slot,
                                 struct CArray_u8 **result_slot);

void hs_temporal_drop_worker_error(struct CWorkerError *err);

void hs_temporal_drop_unit(struct CUnit *unit);

void hs_temporal_drop_worker(struct WorkerRef *worker);

void hs_temporal_new_worker(struct ClientRef *client,
                            const struct CArray_u8 *config,
                            struct WorkerRef **result_slot,
                            struct CWorkerError **error_slot);

void hs_temporal_new_replay_worker(struct RuntimeRef *runtime,
                                   const struct CArray_u8 *config,
                                   struct WorkerRef **worker_slot,
                                   struct HistoryPusher **history_slot,
                                   struct CWorkerError **error_slot);

void hs_temporal_worker_poll_workflow_activation(struct WorkerRef *worker,
                                                 struct MVar *mvar,
                                                 struct Capability cap,
                                                 struct CWorkerError **error_slot,
                                                 struct CArray_u8 **result_slot);

void hs_temporal_worker_poll_activity_task(struct WorkerRef *worker,
                                           struct MVar *mvar,
                                           struct Capability cap,
                                           struct CWorkerError **error_slot,
                                           struct CArray_u8 **result_slot);

void hs_temporal_worker_complete_workflow_activation(struct WorkerRef *worker,
                                                     const struct CArray_u8 *proto,
                                                     struct MVar *mvar,
                                                     struct Capability cap,
                                                     struct CWorkerError **error_slot,
                                                     struct CUnit **result_slot);

void hs_temporal_worker_complete_activity_task(struct WorkerRef *worker,
                                               const struct CArray_u8 *proto,
                                               struct MVar *mvar,
                                               struct Capability cap,
                                               struct CWorkerError **error_slot,
                                               struct CUnit **result_slot);

void hs_temporal_worker_record_activity_heartbeat(struct WorkerRef *worker,
                                                  const struct CArray_u8 *proto,
                                                  struct CWorkerError **error_slot,
                                                  struct CUnit **result_slot);

void hs_temporal_worker_request_workflow_eviction(struct WorkerRef *worker,
                                                  const struct CArray_u8 *run_id);

void hs_temporal_worker_initiate_shutdown(struct WorkerRef *worker);

void hs_temporal_worker_finalize_shutdown(struct WorkerRef *worker,
                                          struct MVar *mvar,
                                          struct Capability cap,
                                          struct CWorkerError **error_slot,
                                          struct CUnit **result_slot);

void hs_temporal_history_pusher_push_history(struct HistoryPusher *history_pusher,
                                             const struct CArray_u8 *workflow_id,
                                             const struct CArray_u8 *history_proto,
                                             struct MVar *mvar,
                                             struct Capability cap,
                                             struct CWorkerError **error_slot,
                                             struct CUnit **result_slot);

void hs_temporal_history_pusher_close(struct HistoryPusher *history_pusher);

void hs_temporal_history_pusher_drop(struct HistoryPusher *history_pusher);

void hs_temporal_start_dev_server(struct RuntimeRef *runtime,
                                  const char *json_string,
                                  struct MVar *mvar,
                                  struct Capability cap,
                                  struct CArray_u8 **error_slot,
                                  struct EphemeralServerRef **result_slot);

void hs_temporal_shutdown_ephemeral_server(struct EphemeralServerRef *server,
                                           struct MVar *mvar,
                                           struct Capability cap,
                                           struct CArray_u8 **error_slot,
                                           struct CUnit **result_slot);

void hs_temporal_start_test_server(struct RuntimeRef *runtime,
                                   const char *json_string,
                                   struct MVar *mvar,
                                   struct Capability cap,
                                   struct CArray_u8 **error_slot,
                                   struct EphemeralServerRef **result_slot);
