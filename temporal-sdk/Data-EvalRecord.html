<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.EvalRecord</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">temporal-sdk</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Data.EvalRecord.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.EvalRecord</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Type Witnesses</a><ul><li><a href="#g:2">Lenses</a></li></ul></li><li><a href="#g:3">Functor</a></li><li><a href="#g:4">Traversable</a><ul><li><a href="#g:5">Utility functions</a></li></ul></li><li><a href="#g:6">Distributive</a></li><li><a href="#g:7">Applicative</a><ul><li><a href="#g:8">Utility functions</a></li></ul></li><li><a href="#g:9">Constraints</a><ul><li><a href="#g:10">Utility functions</a></li></ul></li><li><a href="#g:11">Partial record mapping</a></li><li><a href="#g:12">Reexports</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module is intended to be imported qualified, to avoid name clashes with
Prelude and base functions:</p><pre>import qualified Data.EvalRecord as Rec
</pre><p>A common Haskell idiom is to parameterise a datatype by a functor or GADT
(or any &quot;indexed type&quot; <code>k -&gt; <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#v:Type" title="Data.Kind">Type</a></code></code>), a pattern
sometimes called <a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/">HKD</a>).
This parameter acts as a wrapper of the base type, turning it into a record
that serves a different purpose. The canonical example would be:</p><pre>data Person f
  = Person
      { name :: f <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>
      , age  :: f <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code>
      }
</pre><p>However, this library uses a different approach, where the parameter is
a type-level function <code>Type -&gt; Exp Type</code>, from the <code>first-class-families</code> package.
The type of each field is then given by applying 'Eval (f x)' (also known as <code>@@</code>) to the field:</p><pre>data Person (f :: Type -&gt; <code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a></code> Type)
  = Person
      { name :: f <code>@@</code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>
      , age  :: f <code>@@</code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code>
      }
</pre><p>Let's say that we are writing an application where <code>Person</code> data
will be read from a web form, validated, and stored in a database. Some
possibles outfits that we could use along the way are:</p><pre>-- for the raw input from the web-form,
webInput :: Person (<code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:ConstFn" title="Fcf.Combinators">ConstFn</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>)
webInput = Person <a href="John.html">John</a> &quot;30b&quot;

-- for the result of parsing and validating,
validated :: Person (<code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a></code> (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>))
validated = Person (Right <a href="John.html">John</a>) (Left &quot;Not a number&quot;)

-- Person <code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a></code> for the actual data,
domainModel :: Person <code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a></code>
domainModel = Person <a href="John.html">John</a> 30

dbModel :: Person (<code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a></code> DbColumn) -- To describe how to read / write a <code>Person</code> to the db
dbModel = Person
  { name = DbColumn &quot;name&quot; (Right . fromString) toDbString
  , age  = DbColumn &quot;age&quot;  (readEither . fromString) show
  }

data DbColumn a
  = DbColumn
      { colName :: <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>
      , fromDb  :: DbDataParser a
      , toDb    :: a -&gt; DbData
      }
</pre><p>In such application it is likely that one will have lots of types like
<code>Person</code> so we will like to handle these transformations uniformly,
without boilerplate or repetitions.  This package provides classes to
manipulate these types, using notions that are familiar to haskellers like
<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a></code>, <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> or <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a></code>. For example, instead of writing
an ad-hoc function that checks that all fields have a correct value, like</p><pre>checkPerson :: Person (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>) -&gt; <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> [<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>] (Person <code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a></code>)
</pre><p>we can write only one such function:</p><pre>check :: <code><a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a></code> rec =&gt; rec (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>) -&gt; <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> [<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>] (rec <code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a></code>)
check be
  = case <code><a href="Data-EvalRecord.html#v:traverse" title="Data.EvalRecord">traverse</a></code> (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#v:either" title="Data.Either">either</a></code> (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Function.html#v:const" title="Data.Function">const</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>) <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>) be of
      <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code> bi -&gt; <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#v:Right" title="Data.Either">Right</a></code> bi
      <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> -&gt; <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code> (<code><a href="Data-EvalRecord.html#v:foldMap" title="Data.EvalRecord">foldMap</a></code> (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#v:either" title="Data.Either">either</a></code> (:[]) (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Function.html#v:const" title="Data.Function">const</a></code> [])) be)
</pre><p>Moreover, these classes come with template-haskell functions to derive
the instances automatically, so that one can write:</p><pre>import Data.EvalRecord
import Data.EvalRecord.TH

mkEvalRecord [d|
  data Bump = Bump
    { bump :: Maybe Int
    , bomp :: Bool
    , bamp :: String
    } deriving (Read, Show, Eq, Ord)
  |]
</pre></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="#t:WitnessFieldTypes">WitnessFieldTypes</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span><ul class="subs"><li><a href="#v:typeName">typeName</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> rec -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li><a href="#v:typeProxies">typeProxies</a> :: rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> (<a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>))</li><li><a href="#v:getAccessors">getAccessors</a> :: rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> (<a href="Data-EvalRecord.html#t:LensRec" title="Data.EvalRecord">LensRec</a> rec))</li><li><a href="#v:nestedFieldNames">nestedFieldNames</a> :: rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:ConstFn" title="Fcf.Combinators">ConstFn</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>) :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Metadata">Metadata</a> (a :: k) <span class="keyword">where</span><ul class="subs"><li><a href="#v:Metadata">Metadata</a> :: <span class="keyword">forall</span> {k} (a :: k). <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> a =&gt; {..} -&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:LensRec">LensRec</a> (rec :: (k -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (a :: k) = <a href="#v:LensRec">LensRec</a> {<ul class="subs"><li><a href="#v:view">view</a> :: <span class="keyword">forall</span> (f :: k -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). rec f -&gt; f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a</li><li><a href="#v:set">set</a> :: <span class="keyword">forall</span> (f :: k -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec f</li></ul>}</li><li class="src short"><a href="#v:getLens">getLens</a> :: <span class="keyword">forall</span> {k1} f rec (a :: k1) (h :: k1 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; <a href="Data-EvalRecord.html#t:LensRec" title="Data.EvalRecord">LensRec</a> rec a -&gt; ((h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; f (h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)) -&gt; rec h -&gt; f (rec h)</li><li class="src short"><a href="#v:nestLens">nestLens</a> :: <span class="keyword">forall</span> {k} a b (c :: k). (<span class="keyword">forall</span> (h :: k -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). a h -&gt; (b h -&gt; a h, b h)) -&gt; <a href="Data-EvalRecord.html#t:LensRec" title="Data.EvalRecord">LensRec</a> b c -&gt; <a href="Data-EvalRecord.html#t:LensRec" title="Data.EvalRecord">LensRec</a> a c</li><li class="src short"><span class="keyword">class</span> <a href="#t:FunctorRec">FunctorRec</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span><ul class="subs"><li><a href="#v:map">map</a> :: <span class="keyword">forall</span> (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec g</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec =&gt; <a href="#t:TraversableRec">TraversableRec</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span><ul class="subs"><li><a href="#v:traverse">traverse</a> :: <span class="keyword">forall</span> e (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)) -&gt; rec f -&gt; e (rec g)</li><li><a href="#v:traverse_">traverse_</a> :: <span class="keyword">forall</span> e (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) c. <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e c) -&gt; rec f -&gt; e ()</li></ul></li><li class="src short"><a href="#v:for">for</a> :: <span class="keyword">forall</span> rec e (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> rec, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e) =&gt; rec f -&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)) -&gt; e (rec g)</li><li class="src short"><a href="#v:for_">for_</a> :: <span class="keyword">forall</span> rec e (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) c. (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> rec, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e) =&gt; rec f -&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e c) -&gt; e ()</li><li class="src short"><a href="#v:foldMap">foldMap</a> :: <span class="keyword">forall</span> rec m (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> rec, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m) =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; m) -&gt; rec f -&gt; m</li><li class="src short"><a href="#v:sequence">sequence</a> :: <span class="keyword">forall</span> e rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e, <a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> rec) =&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> e <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:-60--61--60-" title="Fcf.Combinators">&lt;=&lt;</a> f) -&gt; e (rec f)</li><li class="src short"><a href="#v:sequence-39-">sequence'</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e, <a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> rec) =&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> e) -&gt; e (rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>))</li><li class="src short"><span class="keyword">class</span> <a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec =&gt; <a href="#t:DistributiveRec">DistributiveRec</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span><ul class="subs"><li><a href="#v:distribute">distribute</a> :: <span class="keyword">forall</span> f (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; f (rec g) -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:-60--61--60-" title="Fcf.Combinators">&lt;=&lt;</a> g)</li></ul></li><li class="src short"><a href="#v:distribute-39-">distribute'</a> :: (<a href="Data-EvalRecord.html#t:DistributiveRec" title="Data.EvalRecord">DistributiveRec</a> rec, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f) =&gt; f (rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)) -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> f)</li><li class="src short"><a href="#v:cotraverse">cotraverse</a> :: <span class="keyword">forall</span> rec f (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:DistributiveRec" title="Data.EvalRecord">DistributiveRec</a> rec, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f) =&gt; (<span class="keyword">forall</span> a. f (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; f a) -&gt; f (rec g) -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> f)</li><li class="src short"><a href="#v:decompose">decompose</a> :: <a href="Data-EvalRecord.html#t:DistributiveRec" title="Data.EvalRecord">DistributiveRec</a> rec =&gt; (a -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)) -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> ((-&gt;) a))</li><li class="src short"><a href="#v:recompose">recompose</a> :: <a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec =&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> ((-&gt;) a)) -&gt; a -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)</li><li class="src short"><span class="keyword">class</span> <a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec =&gt; <a href="#t:ApplicativeRec">ApplicativeRec</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span><ul class="subs"><li><a href="#v:pure">pure</a> :: <span class="keyword">forall</span> (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f</li><li><a href="#v:prod">prod</a> :: <span class="keyword">forall</span> (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). rec f -&gt; rec g -&gt; rec (<a href="Data-EvalRecord.html#t:Tuple2" title="Data.EvalRecord">Tuple2</a> f g)</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Tuple2">Tuple2</a> (a :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (b :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) c d</li><li class="src short"><a href="#v:zip">zip</a> :: <span class="keyword">forall</span> rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> rec =&gt; rec f -&gt; rec g -&gt; rec (<a href="Data-EvalRecord.html#t:Tuple2" title="Data.EvalRecord">Tuple2</a> f g)</li><li class="src short"><a href="#v:unzip">unzip</a> :: <span class="keyword">forall</span> rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> rec =&gt; rec (<a href="Data-EvalRecord.html#t:Tuple2" title="Data.EvalRecord">Tuple2</a> f g) -&gt; (rec f, rec g)</li><li class="src short"><a href="#v:zipWith">zipWith</a> :: <span class="keyword">forall</span> rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> rec =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec g -&gt; rec h</li><li class="src short"><a href="#v:zipWith3">zipWith3</a> :: <span class="keyword">forall</span> rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (i :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> rec =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; i <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec g -&gt; rec h -&gt; rec i</li><li class="src short"><a href="#v:zipWith4">zipWith4</a> :: <span class="keyword">forall</span> rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (i :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (j :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> rec =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (i <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; j <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec g -&gt; rec h -&gt; rec i -&gt; rec j</li><li class="src short"><span class="keyword">class</span> <a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec =&gt; <a href="#t:ConstraintsRec">ConstraintsRec</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:AllRec">AllRec</a> (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)</li><li><a href="#v:addDicts">addDicts</a> :: <span class="keyword">forall</span> (c :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c rec =&gt; rec f -&gt; rec (<a href="Data-EvalRecord.html#t:Tuple2" title="Data.EvalRecord">Tuple2</a> (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> (<a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c)) f)</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:AllRecF">AllRecF</a> (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (f :: k1 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k) (b :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) = <a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> (<a href="Data-EvalRecord.html#t:ClassF" title="Data.EvalRecord">ClassF</a> c f) b</li><li class="src short"><span class="keyword">class</span> c (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) =&gt; <a href="#t:ClassF">ClassF</a> (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (f :: k1 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k) (a :: k1)</li><li class="src short"><span class="keyword">class</span> c (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) =&gt; <a href="#t:ClassFG">ClassFG</a> (c :: k -&gt; k1 -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (f :: k2 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k) (g :: k2 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k1) (a :: k2)</li><li class="src short"><span class="keyword">class</span> (c a, d a) =&gt; ((c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) <a href="#t:-38-">&amp;</a> (d :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>)) (a :: k)</li><li class="src short"><span class="keyword">data</span> <a href="#t:Dict">Dict</a> (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (a :: k) <span class="keyword">where</span><ul class="subs"><li><a href="#v:Dict">Dict</a> :: <span class="keyword">forall</span> {k} (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (a :: k). c a =&gt; <a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a</li></ul></li><li class="src short"><a href="#v:dicts">dicts</a> :: <span class="keyword">forall</span> (c :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) b. (<a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b) =&gt; b (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> (<a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c))</li><li class="src short"><a href="#v:requiringDict">requiringDict</a> :: <span class="keyword">forall</span> {k} c (a :: k) r. (c a =&gt; r) -&gt; <a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a -&gt; r</li><li class="src short"><a href="#v:mapC">mapC</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; b f -&gt; b g</li><li class="src short"><a href="#v:foldMapC">foldMapC</a> :: <span class="keyword">forall</span> c b m (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; m) -&gt; b f -&gt; m</li><li class="src short"><a href="#v:traverseC">traverseC</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e. (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)) -&gt; b f -&gt; e (b g)</li><li class="src short"><a href="#v:forC">forC</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e. (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e) =&gt; b f -&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)) -&gt; e (b g)</li><li class="src short"><a href="#v:zipWithC">zipWithC</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; b f -&gt; b g -&gt; b h</li><li class="src short"><a href="#v:zipWith3C">zipWith3C</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (i :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; i <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; b f -&gt; b g -&gt; b h -&gt; b i</li><li class="src short"><a href="#v:zipWith4C">zipWith4C</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (i :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (j :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (i <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; j <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; b f -&gt; b g -&gt; b h -&gt; b i -&gt; b j</li><li class="src short"><a href="#v:pureC">pureC</a> :: <span class="keyword">forall</span> c (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) b. (<a href="Data-EvalRecord.html#t:AllRecF" title="Data.EvalRecord">AllRecF</a> c f b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b) =&gt; (<span class="keyword">forall</span> a. c (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; b f</li><li class="src short"><a href="#v:mempty">mempty</a> :: <span class="keyword">forall</span> (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) b. (<a href="Data-EvalRecord.html#t:AllRecF" title="Data.EvalRecord">AllRecF</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> f b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b) =&gt; b f</li><li class="src short"><span class="keyword">data</span> <a href="#t:MapMatches">MapMatches</a> (pred :: k) (f :: k1) a b</li><li class="src short"><span class="keyword">type family</span> <a href="#t:ValueOnMatch">ValueOnMatch</a> (cond :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) (b :: k) (a :: k) :: k <span class="keyword">where ...</span></li><li class="src short"><span class="keyword">class</span> <a href="#t:ApplyOnMatch">ApplyOnMatch</a> (cond :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</li><li class="src short"><a href="#v:mapMatching">mapMatching</a> :: <span class="keyword">forall</span> (pred :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) rec. (<a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> rec, <a href="Data-EvalRecord.html#t:AllRecF" title="Data.EvalRecord">AllRecF</a> <a href="Data-EvalRecord.html#t:ApplyOnMatch" title="Data.EvalRecord">ApplyOnMatch</a> (pred <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:-60--61--60-" title="Fcf.Combinators">&lt;=&lt;</a> f) rec) =&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> pred -&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:-60--61--60-" title="Fcf.Combinators">&lt;=&lt;</a> f) <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec (<a href="Data-EvalRecord.html#t:MapMatches" title="Data.EvalRecord">MapMatches</a> pred g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:-60--61--60-" title="Fcf.Combinators">&lt;=&lt;</a> f)</li><li class="src short"><a href="#v:applyPred">applyPred</a> :: <span class="keyword">forall</span> {k} (pred :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k) a. <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> pred -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> (pred <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)</li><li class="src short">module <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf.html">Fcf</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Type Witnesses</h1></a><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:WitnessFieldTypes" class="def">WitnessFieldTypes</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span> <a href="src/Data.EvalRecord.html#WitnessFieldTypes" class="link">Source</a> <a href="#t:WitnessFieldTypes" class="selflink">#</a></p><div class="doc"><p>Functions that try to convert from f @@ a to some other type don't work without a little
help due to injectivity. This class provides that help by providing a function that provides
a witness of the type of a for each field of the record.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Data-EvalRecord.html#v:typeProxies" title="Data.EvalRecord">typeProxies</a>, <a href="Data-EvalRecord.html#v:getAccessors" title="Data.EvalRecord">getAccessors</a>, <a href="Data-EvalRecord.html#v:nestedFieldNames" title="Data.EvalRecord">nestedFieldNames</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:typeName" class="def">typeName</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> rec -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Data.EvalRecord.html#typeName" class="link">Source</a> <a href="#v:typeName" class="selflink">#</a></p> <div class="subs default"><p class="caption"></p><p class="src"><span class="keyword">default</span> <a id="v:typeName" class="def">typeName</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> rec =&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> rec -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Data.EvalRecord.html#typeName" class="link">Source</a> <a href="#v:typeName" class="selflink">#</a></p></div><p class="src"><a id="v:typeProxies" class="def">typeProxies</a> :: rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> (<a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)) <a href="src/Data.EvalRecord.html#typeProxies" class="link">Source</a> <a href="#v:typeProxies" class="selflink">#</a></p><p class="src"><a id="v:getAccessors" class="def">getAccessors</a> :: rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> (<a href="Data-EvalRecord.html#t:LensRec" title="Data.EvalRecord">LensRec</a> rec)) <a href="src/Data.EvalRecord.html#getAccessors" class="link">Source</a> <a href="#v:getAccessors" class="selflink">#</a></p><p class="src"><a id="v:nestedFieldNames" class="def">nestedFieldNames</a> :: rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:ConstFn" title="Fcf.Combinators">ConstFn</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>) :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <a href="src/Data.EvalRecord.html#nestedFieldNames" class="link">Source</a> <a href="#v:nestedFieldNames" class="selflink">#</a></p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Metadata" class="def">Metadata</a> (a :: k) <span class="keyword">where</span> <a href="src/Data.EvalRecord.html#Metadata" class="link">Source</a> <a href="#t:Metadata" class="selflink">#</a></p><div class="doc"><p>A type witness for a field of type <code>a</code>.</p><p>For convenience, it also carries <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a></code> evidence and the name of the field.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Metadata" class="def">Metadata</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src">:: <span class="keyword">forall</span> {k} (a :: k). <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Dynamic.html#t:Typeable" title="Data.Dynamic">Typeable</a> a</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src">=&gt; { <a id="v:name" class="def">name</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src">&nbsp;&nbsp;&nbsp;} -&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div></div><a href="#g:2" id="g:2"><h2>Lenses</h2></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:LensRec" class="def">LensRec</a> (rec :: (k -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (a :: k) <a href="src/Data.EvalRecord.html#LensRec" class="link">Source</a> <a href="#t:LensRec" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:LensRec" class="def">LensRec</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:view" class="def">view</a> :: <span class="keyword">forall</span> (f :: k -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). rec f -&gt; f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:set" class="def">set</a> :: <span class="keyword">forall</span> (f :: k -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec f</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><a id="v:getLens" class="def">getLens</a> :: <span class="keyword">forall</span> {k1} f rec (a :: k1) (h :: k1 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; <a href="Data-EvalRecord.html#t:LensRec" title="Data.EvalRecord">LensRec</a> rec a -&gt; ((h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; f (h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)) -&gt; rec h -&gt; f (rec h) <a href="src/Data.EvalRecord.html#getLens" class="link">Source</a> <a href="#v:getLens" class="selflink">#</a></p><div class="doc"><p>Obtain a van-laarhoven lens (compatible with the lens library) from <code><a href="Data-EvalRecord.html#t:LensRec" title="Data.EvalRecord">LensRec</a></code></p></div></div><div class="top"><p class="src"><a id="v:nestLens" class="def">nestLens</a> :: <span class="keyword">forall</span> {k} a b (c :: k). (<span class="keyword">forall</span> (h :: k -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). a h -&gt; (b h -&gt; a h, b h)) -&gt; <a href="Data-EvalRecord.html#t:LensRec" title="Data.EvalRecord">LensRec</a> b c -&gt; <a href="Data-EvalRecord.html#t:LensRec" title="Data.EvalRecord">LensRec</a> a c <a href="src/Data.EvalRecord.html#nestLens" class="link">Source</a> <a href="#v:nestLens" class="selflink">#</a></p></div><a href="#g:3" id="g:3"><h1>Functor</h1></a><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:FunctorRec" class="def">FunctorRec</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span> <a href="src/Data.EvalRecord.html#FunctorRec" class="link">Source</a> <a href="#t:FunctorRec" class="selflink">#</a></p><div class="doc"><p>Record-types that can be mapped over. Instances of <code><a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a></code> should
  satisfy the following laws:</p><pre><code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Function.html#v:id" title="Data.Function">id</a></code> = <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Function.html#v:id" title="Data.Function">id</a></code>
<code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> f . <code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> g = <code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> (f . g)
</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:map" class="def">map</a> :: <span class="keyword">forall</span> (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec g <a href="src/Data.EvalRecord.html#map" class="link">Source</a> <a href="#v:map" class="selflink">#</a></p></div></div><a href="#g:4" id="g:4"><h1>Traversable</h1></a><div class="top"><p class="src"><span class="keyword">class</span> <a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec =&gt; <a id="t:TraversableRec" class="def">TraversableRec</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span> <a href="src/Data.EvalRecord.html#TraversableRec" class="link">Source</a> <a href="#t:TraversableRec" class="selflink">#</a></p><div class="doc"><p>Record-types that can be traversed from left to right. Instances should
  satisfy the following laws:</p><pre> t . <code><a href="Data-EvalRecord.html#v:traverse" title="Data.EvalRecord">traverse</a></code> f   = <code><a href="Data-EvalRecord.html#v:traverse" title="Data.EvalRecord">traverse</a></code> (t . f)  -- naturality
<code><a href="Data-EvalRecord.html#v:traverse" title="Data.EvalRecord">traverse</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Functor.html#v:Identity" title="Data.Functor">Identity</a></code> = <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Functor.html#v:Identity" title="Data.Functor">Identity</a></code>           -- identity
<code><a href="Data-EvalRecord.html#v:traverse" title="Data.EvalRecord">traverse</a></code> (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#v:fmap" title="Control.Monad">fmap</a></code> g . f) = <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#v:fmap" title="Control.Monad">fmap</a></code> (<code><a href="Data-EvalRecord.html#v:traverse" title="Data.EvalRecord">traverse</a></code> g) . <code><a href="Data-EvalRecord.html#v:traverse" title="Data.EvalRecord">traverse</a></code> f -- composition
</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:traverse" class="def">traverse</a> :: <span class="keyword">forall</span> e (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)) -&gt; rec f -&gt; e (rec g) <a href="src/Data.EvalRecord.html#traverse" class="link">Source</a> <a href="#v:traverse" class="selflink">#</a></p><p class="src"><a id="v:traverse_" class="def">traverse_</a> :: <span class="keyword">forall</span> e (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) c. <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e c) -&gt; rec f -&gt; e () <a href="src/Data.EvalRecord.html#traverse_" class="link">Source</a> <a href="#v:traverse_" class="selflink">#</a></p><div class="doc"><p>Map each element to an action, evaluate these actions from left to right,
   and ignore the results.</p></div></div></div><a href="#g:5" id="g:5"><h2>Utility functions</h2></a><div class="top"><p class="src"><a id="v:for" class="def">for</a> :: <span class="keyword">forall</span> rec e (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> rec, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e) =&gt; rec f -&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)) -&gt; e (rec g) <a href="src/Data.EvalRecord.html#for" class="link">Source</a> <a href="#v:for" class="selflink">#</a></p><div class="doc"><p><code><a href="Data-EvalRecord.html#v:traverse" title="Data.EvalRecord">traverse</a></code> with the arguments flipped. Useful when the traversing function is a large lambda:</p><pre>for someRecord $ fa -&gt; ...
</pre><p><em>Since: 0.0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:for_" class="def">for_</a> :: <span class="keyword">forall</span> rec e (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) c. (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> rec, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e) =&gt; rec f -&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e c) -&gt; e () <a href="src/Data.EvalRecord.html#for_" class="link">Source</a> <a href="#v:for_" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:foldMap" class="def">foldMap</a> :: <span class="keyword">forall</span> rec m (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> rec, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m) =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; m) -&gt; rec f -&gt; m <a href="src/Data.EvalRecord.html#foldMap" class="link">Source</a> <a href="#v:foldMap" class="selflink">#</a></p><div class="doc"><p>Map each element to a monoid, and combine the results.</p></div></div><div class="top"><p class="src"><a id="v:sequence" class="def">sequence</a> :: <span class="keyword">forall</span> e rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e, <a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> rec) =&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> e <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:-60--61--60-" title="Fcf.Combinators">&lt;=&lt;</a> f) -&gt; e (rec f) <a href="src/Data.EvalRecord.html#sequence" class="link">Source</a> <a href="#v:sequence" class="selflink">#</a></p><div class="doc"><p>Evaluate each action in the structure from left to right,
  and collect the results.</p></div></div><div class="top"><p class="src"><a id="v:sequence-39-" class="def">sequence'</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e, <a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> rec) =&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> e) -&gt; e (rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)) <a href="src/Data.EvalRecord.html#sequence%27" class="link">Source</a> <a href="#v:sequence-39-" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Data-EvalRecord.html#v:sequence" title="Data.EvalRecord">sequence</a></code> with <code>f</code> specialized to <code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a></code>.</p></div></div><a href="#g:6" id="g:6"><h1>Distributive</h1></a><div class="top"><p class="src"><span class="keyword">class</span> <a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec =&gt; <a id="t:DistributiveRec" class="def">DistributiveRec</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span> <a href="src/Data.EvalRecord.html#DistributiveRec" class="link">Source</a> <a href="#t:DistributiveRec" class="selflink">#</a></p><div class="doc"><p>A <code><a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a></code> where the effects can be distributed to the fields:
 <code><a href="Data-EvalRecord.html#v:distribute" title="Data.EvalRecord">distribute</a></code> turns an effectful way of building a Record-type
 into a pure Record-type with effectful ways of computing the
 values of its fields.</p><p>This class is the categorical dual of <code><a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a></code>,
 with <code><a href="Data-EvalRecord.html#v:distribute" title="Data.EvalRecord">distribute</a></code> the dual of <code><a href="Data-EvalRecord.html#v:sequence" title="Data.EvalRecord">sequence</a></code>
 and <code><a href="Data-EvalRecord.html#v:cotraverse" title="Data.EvalRecord">cotraverse</a></code> the dual of <code><a href="Data-EvalRecord.html#v:traverse" title="Data.EvalRecord">traverse</a></code>. As such,
 instances need to satisfy these laws:</p><pre><code><a href="Data-EvalRecord.html#v:distribute" title="Data.EvalRecord">distribute</a></code> . h = <code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> h) . <code><a href="Data-EvalRecord.html#v:distribute" title="Data.EvalRecord">distribute</a></code>    -- naturality
<code><a href="Data-EvalRecord.html#v:distribute" title="Data.EvalRecord">distribute</a></code> . <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Functor.html#v:Identity" title="Data.Functor">Identity</a></code> = <code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Functor.html#v:Identity" title="Data.Functor">Identity</a></code>                 -- identity
</pre><p>By specializing <code>f</code> to <code>((-&gt;) a)</code> and <code>g</code> to <code>Identity</code>, we can define a function that
decomposes a function on distributive records into a collection of simpler functions:</p><pre><code><a href="Data-EvalRecord.html#v:decompose" title="Data.EvalRecord">decompose</a></code> :: <code><a href="Data-EvalRecord.html#t:DistributiveRec" title="Data.EvalRecord">DistributiveRec</a></code> b =&gt; (a -&gt; b <code>Identity</code>) -&gt; b ((-&gt;) a)
<code><a href="Data-EvalRecord.html#v:decompose" title="Data.EvalRecord">decompose</a></code> = <code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#v:fmap" title="Control.Monad">fmap</a></code> <code>runIdentity</code> . <code>getCompose</code>) . <code><a href="Data-EvalRecord.html#v:distribute" title="Data.EvalRecord">distribute</a></code>
</pre><p>Lawful instances of the class can then be characterized as those that satisfy:</p><pre><code><a href="Data-EvalRecord.html#v:recompose" title="Data.EvalRecord">recompose</a></code> . <code><a href="Data-EvalRecord.html#v:decompose" title="Data.EvalRecord">decompose</a></code> = <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Function.html#v:id" title="Data.Function">id</a></code>
<code><a href="Data-EvalRecord.html#v:decompose" title="Data.EvalRecord">decompose</a></code> . <code><a href="Data-EvalRecord.html#v:recompose" title="Data.EvalRecord">recompose</a></code> = <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Function.html#v:id" title="Data.Function">id</a></code>
</pre><p>This means intuitively that instances need to have a fixed shape (i.e. no sum-types can be involved).
Typically, this means record types, as long as they don't contain fields where the functor argument is not applied.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:distribute" class="def">distribute</a> :: <span class="keyword">forall</span> f (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; f (rec g) -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:-60--61--60-" title="Fcf.Combinators">&lt;=&lt;</a> g) <a href="src/Data.EvalRecord.html#distribute" class="link">Source</a> <a href="#v:distribute" class="selflink">#</a></p></div></div><div class="top"><p class="src"><a id="v:distribute-39-" class="def">distribute'</a> :: (<a href="Data-EvalRecord.html#t:DistributiveRec" title="Data.EvalRecord">DistributiveRec</a> rec, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f) =&gt; f (rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)) -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> f) <a href="src/Data.EvalRecord.html#distribute%27" class="link">Source</a> <a href="#v:distribute-39-" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Data-EvalRecord.html#v:distribute" title="Data.EvalRecord">distribute</a></code> with <code>g</code> specialized to <code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:cotraverse" class="def">cotraverse</a> :: <span class="keyword">forall</span> rec f (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:DistributiveRec" title="Data.EvalRecord">DistributiveRec</a> rec, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f) =&gt; (<span class="keyword">forall</span> a. f (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; f a) -&gt; f (rec g) -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> f) <a href="src/Data.EvalRecord.html#cotraverse" class="link">Source</a> <a href="#v:cotraverse" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:decompose" class="def">decompose</a> :: <a href="Data-EvalRecord.html#t:DistributiveRec" title="Data.EvalRecord">DistributiveRec</a> rec =&gt; (a -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)) -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> ((-&gt;) a)) <a href="src/Data.EvalRecord.html#decompose" class="link">Source</a> <a href="#v:decompose" class="selflink">#</a></p><div class="doc"><p>Decompose a function returning a distributive record into
  a collection of simpler functions.</p></div></div><div class="top"><p class="src"><a id="v:recompose" class="def">recompose</a> :: <a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec =&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> ((-&gt;) a)) -&gt; a -&gt; rec (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure" title="Fcf.Combinators">Pure</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <a href="src/Data.EvalRecord.html#recompose" class="link">Source</a> <a href="#v:recompose" class="selflink">#</a></p><div class="doc"><p>Recompose a decomposed function.</p></div></div><a href="#g:7" id="g:7"><h1>Applicative</h1></a><div class="top"><p class="src"><span class="keyword">class</span> <a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec =&gt; <a id="t:ApplicativeRec" class="def">ApplicativeRec</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span> <a href="src/Data.EvalRecord.html#ApplicativeRec" class="link">Source</a> <a href="#t:ApplicativeRec" class="selflink">#</a></p><div class="doc"><p>A <code><a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a></code> with application, providing operations to:</p><ul><li>embed an &quot;empty&quot; value (<code><a href="Data-EvalRecord.html#v:pure" title="Data.EvalRecord">pure</a></code>)</li><li>align and combine values (<code><a href="Data-EvalRecord.html#v:prod" title="Data.EvalRecord">prod</a></code>)</li></ul><p>It should satisfy the following laws:</p><dl><dt>Naturality of <code><a href="Data-EvalRecord.html#v:prod" title="Data.EvalRecord">prod</a></code></dt><dd></dd></dl><pre><code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> ((a, b) -&gt; (f a, g b)) (u `<code>prod'</code> v) = <code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> f u `<code>prod'</code> <code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> g v
</pre><dl><dt>Left and right identity</dt><dd></dd></dl><pre><code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> ((_, b) -&gt; b) (<code><a href="Data-EvalRecord.html#v:pure" title="Data.EvalRecord">pure</a></code> e `<code>prod'</code> v) = v
<code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> ((a, _) -&gt; a) (u `<code>prod'</code> <code><a href="Data-EvalRecord.html#v:pure" title="Data.EvalRecord">pure</a></code> e) = u
</pre><dl><dt>Associativity</dt><dd></dd></dl><pre><code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> ((a, (b, c)) -&gt; ((a, b), c) (u `<code>prod'</code> (v `<code>prod'</code> w)) = (u `<code>prod'</code> v) `<code>prod'</code> w
</pre><p>It is to <code><a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a></code> in the same way as <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code>
 relates to <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a></code>. For a presentation of <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> as
 a monoidal functor, see Section 7 of
 <a href="http://www.soi.city.ac.uk/~ross/papers/Applicative.html">Applicative Programming with Effects</a>.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:pure" class="def">pure</a> :: <span class="keyword">forall</span> (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f <a href="src/Data.EvalRecord.html#pure" class="link">Source</a> <a href="#v:pure" class="selflink">#</a></p><p class="src"><a id="v:prod" class="def">prod</a> :: <span class="keyword">forall</span> (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). rec f -&gt; rec g -&gt; rec (<a href="Data-EvalRecord.html#t:Tuple2" title="Data.EvalRecord">Tuple2</a> f g) <a href="src/Data.EvalRecord.html#prod" class="link">Source</a> <a href="#v:prod" class="selflink">#</a></p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Tuple2" class="def">Tuple2</a> (a :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (b :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) c d <a href="src/Data.EvalRecord.html#Tuple2" class="link">Source</a> <a href="#t:Tuple2" class="selflink">#</a></p><div class="doc"><p>A first-class-families version of <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Functor-Product.html#v:Product" title="Data.Functor.Product">Product</a></code>.</p><p>When used with <code><a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Eval" title="Fcf.Core">Eval</a></code>, it resolves in a tuple of the applied type-level functions.</p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Tuple2">Instances</h4><details id="i:Tuple2" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Tuple2:Eval:1"></span> <span class="keyword">type</span> <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Eval" title="Fcf.Core">Eval</a> (<a href="Data-EvalRecord.html#t:Tuple2" title="Data.EvalRecord">Tuple2</a> f g x :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)</span> <a href="src/Data.EvalRecord.html#line-280" class="link">Source</a> <a href="#t:Tuple2" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Tuple2:Eval:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-EvalRecord.html">Data.EvalRecord</a></p> <div class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Eval" title="Fcf.Core">Eval</a> (<a href="Data-EvalRecord.html#t:Tuple2" title="Data.EvalRecord">Tuple2</a> f g x :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) = (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> x, g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> x)</div></details></td></tr></table></details></div></div><a href="#g:8" id="g:8"><h2>Utility functions</h2></a><div class="top"><p class="src"><a id="v:zip" class="def">zip</a> :: <span class="keyword">forall</span> rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> rec =&gt; rec f -&gt; rec g -&gt; rec (<a href="Data-EvalRecord.html#t:Tuple2" title="Data.EvalRecord">Tuple2</a> f g) <a href="src/Data.EvalRecord.html#zip" class="link">Source</a> <a href="#v:zip" class="selflink">#</a></p><div class="doc"><p>An alias of <code><a href="Data-EvalRecord.html#v:prod" title="Data.EvalRecord">prod</a></code>, since this is like a <code><a href="Data-EvalRecord.html#v:zip" title="Data.EvalRecord">zip</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:unzip" class="def">unzip</a> :: <span class="keyword">forall</span> rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> rec =&gt; rec (<a href="Data-EvalRecord.html#t:Tuple2" title="Data.EvalRecord">Tuple2</a> f g) -&gt; (rec f, rec g) <a href="src/Data.EvalRecord.html#unzip" class="link">Source</a> <a href="#v:unzip" class="selflink">#</a></p><div class="doc"><p>An equivalent of <code><a href="Data-EvalRecord.html#v:unzip" title="Data.EvalRecord">unzip</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:zipWith" class="def">zipWith</a> :: <span class="keyword">forall</span> rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> rec =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec g -&gt; rec h <a href="src/Data.EvalRecord.html#zipWith" class="link">Source</a> <a href="#v:zipWith" class="selflink">#</a></p><div class="doc"><p>An equivalent of <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-List.html#v:zipWith" title="Data.List">zipWith</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:zipWith3" class="def">zipWith3</a> :: <span class="keyword">forall</span> rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (i :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> rec =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; i <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec g -&gt; rec h -&gt; rec i <a href="src/Data.EvalRecord.html#zipWith3" class="link">Source</a> <a href="#v:zipWith3" class="selflink">#</a></p><div class="doc"><p>An equivalent of <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-List.html#v:zipWith3" title="Data.List">zipWith3</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:zipWith4" class="def">zipWith4</a> :: <span class="keyword">forall</span> rec (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (i :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (j :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> rec =&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (i <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; j <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec g -&gt; rec h -&gt; rec i -&gt; rec j <a href="src/Data.EvalRecord.html#zipWith4" class="link">Source</a> <a href="#v:zipWith4" class="selflink">#</a></p><div class="doc"><p>An equivalent of <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-List.html#v:zipWith4" title="Data.List">zipWith4</a></code>.</p></div></div><a href="#g:9" id="g:9"><h1>Constraints</h1></a><div class="top"><p class="src"><span class="keyword">class</span> <a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec =&gt; <a id="t:ConstraintsRec" class="def">ConstraintsRec</a> (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span> <a href="src/Data.EvalRecord.html#ConstraintsRec" class="link">Source</a> <a href="#t:ConstraintsRec" class="selflink">#</a></p><div class="doc"><p>Instances of this class provide means to talk about constraints,
  both at compile-time, using <code><a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a></code>, and at run-time, in the form
  of <code><a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a></code>, via <code><a href="Data-EvalRecord.html#v:addDicts" title="Data.EvalRecord">addDicts</a></code>.</p><p>A manual definition would look like this:</p><pre>data T f = A (f <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code>) (f <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>) | B (f <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></code>) (f <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code>)

instance <code>ConstraintsB</code> T where
  type <code><a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a></code> c T = (c <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code>, c <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>, c <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></code>)

  <code><a href="Data-EvalRecord.html#v:addDicts" title="Data.EvalRecord">addDicts</a></code> t = case t of
    A x y -&gt; A (<code><a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a></code>, x) (<code><a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a></code>, y)
    B z w -&gt; B (<code><a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a></code>, z) (<code><a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a></code>, w)
</pre><p>Now, when we given a <code>T f</code>, if we need to use the <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a></code> instance of
their fields, we can use:</p><pre>addDicts' :: AllRec Show b =&gt; b f -&gt; b (<code><a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a></code> `<code>Tuple2'</code> f)
</pre></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a id="t:AllRec" class="def">AllRec</a> (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (rec :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <a href="src/Data.EvalRecord.html#AllRec" class="link">Source</a> <a href="#t:AllRec" class="selflink">#</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:addDicts" class="def">addDicts</a> :: <span class="keyword">forall</span> (c :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c rec =&gt; rec f -&gt; rec (<a href="Data-EvalRecord.html#t:Tuple2" title="Data.EvalRecord">Tuple2</a> (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> (<a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c)) f) <a href="src/Data.EvalRecord.html#addDicts" class="link">Source</a> <a href="#v:addDicts" class="selflink">#</a></p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:AllRecF" class="def">AllRecF</a> (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (f :: k1 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k) (b :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) = <a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> (<a href="Data-EvalRecord.html#t:ClassF" title="Data.EvalRecord">ClassF</a> c f) b <a href="src/Data.EvalRecord.html#AllRecF" class="link">Source</a> <a href="#t:AllRecF" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a></code> but will put the functor argument <code>f</code>
  between the constraint <code>c</code> and the type <code>a</code>. For example:</p><pre> <code><a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a></code>  <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a></code>   Person ~ (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a></code>    <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>,  <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a></code>    <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code>)
 <code><a href="Data-EvalRecord.html#t:AllRecF" title="Data.EvalRecord">AllRecF</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a></code> f Person ~ (<code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a></code> (f @<code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>), <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a></code> (f </code>@ <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code>))
 </pre></div></div><div class="top"><p class="src"><span class="keyword">class</span> c (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) =&gt; <a id="t:ClassF" class="def">ClassF</a> (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (f :: k1 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k) (a :: k1) <a href="src/Data.EvalRecord.html#ClassF" class="link">Source</a> <a href="#t:ClassF" class="selflink">#</a></p><div class="doc"><p><code><a href="Data-EvalRecord.html#t:ClassF" title="Data.EvalRecord">ClassF</a></code> has one universal instance that makes <code><code><a href="Data-EvalRecord.html#t:ClassF" title="Data.EvalRecord">ClassF</a></code> c f a</code>
  equivalent to <code>c (f a)</code>. However, we have</p><pre>'ClassF c f :: k -&gt; <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#v:Constraint" title="Data.Kind">Constraint</a></code>
</pre><p>This is useful since it allows to define constraint-constructors like
<code><code><a href="Data-EvalRecord.html#t:ClassF" title="Data.EvalRecord">ClassF</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a></code> 'Pure1 Maybe'</code></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:ClassF">Instances</h4><details id="i:ClassF" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:ClassF:ClassF:1"></span> c (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) =&gt; <a href="Data-EvalRecord.html#t:ClassF" title="Data.EvalRecord">ClassF</a> (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (f :: k1 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k) (a :: k1)</span> <a href="src/Data.EvalRecord.html#line-685" class="link">Source</a> <a href="#t:ClassF" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:ClassF:ClassF:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-EvalRecord.html">Data.EvalRecord</a></p></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">class</span> c (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) =&gt; <a id="t:ClassFG" class="def">ClassFG</a> (c :: k -&gt; k1 -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (f :: k2 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k) (g :: k2 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k1) (a :: k2) <a href="src/Data.EvalRecord.html#ClassFG" class="link">Source</a> <a href="#t:ClassFG" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Data-EvalRecord.html#t:ClassF" title="Data.EvalRecord">ClassF</a></code> but for binary relations.</p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:ClassFG">Instances</h4><details id="i:ClassFG" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:ClassFG:ClassFG:1"></span> c (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) =&gt; <a href="Data-EvalRecord.html#t:ClassFG" title="Data.EvalRecord">ClassFG</a> (c :: k1 -&gt; k2 -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (f :: k3 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k1) (g :: k3 -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k2) (a :: k3)</span> <a href="src/Data.EvalRecord.html#line-692" class="link">Source</a> <a href="#t:ClassFG" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:ClassFG:ClassFG:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-EvalRecord.html">Data.EvalRecord</a></p></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">class</span> (c a, d a) =&gt; ((c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) <a id="t:-38-" class="def">&amp;</a> (d :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>)) (a :: k) <a href="src/Data.EvalRecord.html#%26" class="link">Source</a> <a href="#t:-38-" class="selflink">#</a></p><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:-38-">Instances</h4><details id="i:-38-" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:-38-:-38-:1"></span> (c a, d a) =&gt; ((c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) <a href="Data-EvalRecord.html#t:-38-" title="Data.EvalRecord">&amp;</a> (d :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>)) (a :: k)</span> <a href="src/Data.EvalRecord.html#line-555" class="link">Source</a> <a href="#t:-38-" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:-38-:-38-:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-EvalRecord.html">Data.EvalRecord</a></p></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Dict" class="def">Dict</a> (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (a :: k) <span class="keyword">where</span> <a href="src/Data.EvalRecord.html#Dict" class="link">Source</a> <a href="#t:Dict" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a></code> c a</code> is evidence that there exists an instance of <code>c a</code>.</p><p>It is essentially equivalent to <code>Dict (c a)</code> from the
  <a href="http://hackage.haskell.org/package/constraints">constraints</a> package,
  but because of its kind, it allows us to define things like <code><code><a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a></code> <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a></code></code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Dict" class="def">Dict</a> :: <span class="keyword">forall</span> {k} (c :: k -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) (a :: k). c a =&gt; <a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Dict">Instances</h4><details id="i:Dict" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Dict:Show:1"></span> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a> (<a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a)</span> <a href="src/Data.EvalRecord.html#line-503" class="link">Source</a> <a href="#t:Dict" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Dict:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-EvalRecord.html">Data.EvalRecord</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a] -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Dict:Eq:2"></span> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a)</span> <a href="src/Data.EvalRecord.html#line-499" class="link">Source</a> <a href="#t:Dict" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Dict:Eq:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-EvalRecord.html">Data.EvalRecord</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a -&gt; <a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a -&gt; <a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:10" id="g:10"><h2>Utility functions</h2></a><div class="top"><p class="src"><a id="v:dicts" class="def">dicts</a> :: <span class="keyword">forall</span> (c :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) b. (<a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b) =&gt; b (<a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:Pure1" title="Fcf.Combinators">Pure1</a> (<a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c)) <a href="src/Data.EvalRecord.html#dicts" class="link">Source</a> <a href="#v:dicts" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Data-EvalRecord.html#v:addDicts" title="Data.EvalRecord">addDicts</a></code> but can produce the instance dictionaries
  &quot;out of the blue&quot;.</p></div></div><div class="top"><p class="src"><a id="v:requiringDict" class="def">requiringDict</a> :: <span class="keyword">forall</span> {k} c (a :: k) r. (c a =&gt; r) -&gt; <a href="Data-EvalRecord.html#t:Dict" title="Data.EvalRecord">Dict</a> c a -&gt; r <a href="src/Data.EvalRecord.html#requiringDict" class="link">Source</a> <a href="#v:requiringDict" class="selflink">#</a></p><div class="doc"><p>Turn a constrained-function into an unconstrained one
  that uses the packed instance dictionary instead.</p></div></div><div class="top"><p class="src"><a id="v:mapC" class="def">mapC</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; b f -&gt; b g <a href="src/Data.EvalRecord.html#mapC" class="link">Source</a> <a href="#v:mapC" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Data-EvalRecord.html#v:map" title="Data.EvalRecord">map</a></code> but a constraint is allowed to be required on
  each element of <code>rec</code></p><p>E.g. If all fields of <code>rec</code> are <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a></code>able then you
could store each shown value in it's slot using 'ConstFn String':</p><pre>showFields :: (AllRec Show rec, ConstraintsRec rec) =&gt; b Pure -&gt; b (ConstFn String)
showFields = mapC @Show showField
  where
    showField :: forall a. Show a =&gt; Metadata a -&gt; a -&gt; String
    showField _ = show</pre><p>Notice that one can use the <code>(&amp;)</code> class as a way to require several
constraints to hold simultaneously:</p><pre>map @(Show &amp; Eq &amp; Enum) r</pre></div></div><div class="top"><p class="src"><a id="v:foldMapC" class="def">foldMapC</a> :: <span class="keyword">forall</span> c b m (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; m) -&gt; b f -&gt; m <a href="src/Data.EvalRecord.html#foldMapC" class="link">Source</a> <a href="#v:foldMapC" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:traverseC" class="def">traverseC</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e. (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)) -&gt; b f -&gt; e (b g) <a href="src/Data.EvalRecord.html#traverseC" class="link">Source</a> <a href="#v:traverseC" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Data-EvalRecord.html#v:traverse" title="Data.EvalRecord">traverse</a></code> but with a constraint on the elements of <code>b</code>.</p></div></div><div class="top"><p class="src"><a id="v:forC" class="def">forC</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e. (<a href="Data-EvalRecord.html#t:TraversableRec" title="Data.EvalRecord">TraversableRec</a> b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> e) =&gt; b f -&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; e (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a)) -&gt; e (b g) <a href="src/Data.EvalRecord.html#forC" class="link">Source</a> <a href="#v:forC" class="selflink">#</a></p><div class="doc"><p><code><a href="Data-EvalRecord.html#v:traverseC" title="Data.EvalRecord">traverseC</a></code> with the arguments flipped. Useful when the traversing function is a large lambda:</p><pre>forC someRec $ fa -&gt; ...
</pre><p><em>Since: 0.0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipWithC" class="def">zipWithC</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; b f -&gt; b g -&gt; b h <a href="src/Data.EvalRecord.html#zipWithC" class="link">Source</a> <a href="#v:zipWithC" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Data-EvalRecord.html#v:zipWith" title="Data.EvalRecord">zipWith</a></code> but with a constraint on the elements of <code>b</code>.</p></div></div><div class="top"><p class="src"><a id="v:zipWith3C" class="def">zipWith3C</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (i :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; i <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; b f -&gt; b g -&gt; b h -&gt; b i <a href="src/Data.EvalRecord.html#zipWith3C" class="link">Source</a> <a href="#v:zipWith3C" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Data-EvalRecord.html#v:zipWith3" title="Data.EvalRecord">zipWith3</a></code> but with a constraint on the elements of <code>b</code>.</p></div></div><div class="top"><p class="src"><a id="v:zipWith4C" class="def">zipWith4C</a> :: <span class="keyword">forall</span> c b (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (h :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (i :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (j :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Data-EvalRecord.html#t:AllRec" title="Data.EvalRecord">AllRec</a> c b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b) =&gt; (<span class="keyword">forall</span> a. c a =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (h <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (i <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; j <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; b f -&gt; b g -&gt; b h -&gt; b i -&gt; b j <a href="src/Data.EvalRecord.html#zipWith4C" class="link">Source</a> <a href="#v:zipWith4C" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Data-EvalRecord.html#v:zipWith4" title="Data.EvalRecord">zipWith4</a></code> but with a constraint on the elements of <code>b</code>.</p></div></div><div class="top"><p class="src"><a id="v:pureC" class="def">pureC</a> :: <span class="keyword">forall</span> c (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) b. (<a href="Data-EvalRecord.html#t:AllRecF" title="Data.EvalRecord">AllRecF</a> c f b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b) =&gt; (<span class="keyword">forall</span> a. c (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) =&gt; <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; b f <a href="src/Data.EvalRecord.html#pureC" class="link">Source</a> <a href="#v:pureC" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Data-EvalRecord.html#v:pure" title="Data.EvalRecord">pure</a></code> but a constraint is allowed to be required on
  each element of <code>b</code>.</p></div></div><div class="top"><p class="src"><a id="v:mempty" class="def">mempty</a> :: <span class="keyword">forall</span> (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) b. (<a href="Data-EvalRecord.html#t:AllRecF" title="Data.EvalRecord">AllRecF</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> f b, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> b, <a href="Data-EvalRecord.html#t:ApplicativeRec" title="Data.EvalRecord">ApplicativeRec</a> b) =&gt; b f <a href="src/Data.EvalRecord.html#mempty" class="link">Source</a> <a href="#v:mempty" class="selflink">#</a></p><div class="doc"><p>Builds a <code>b f</code>, by applying <code><a href="Data-EvalRecord.html#v:mempty" title="Data.EvalRecord">mempty</a></code> on every field of <code>b</code>.</p></div></div><a href="#g:11" id="g:11"><h1>Partial record mapping</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:MapMatches" class="def">MapMatches</a> (pred :: k) (f :: k1) a b <a href="src/Data.EvalRecord.html#MapMatches" class="link">Source</a> <a href="#t:MapMatches" class="selflink">#</a></p><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:MapMatches">Instances</h4><details id="i:MapMatches" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:MapMatches:Eval:1"></span> <span class="keyword">type</span> <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Eval" title="Fcf.Core">Eval</a> (<a href="Data-EvalRecord.html#t:MapMatches" title="Data.EvalRecord">MapMatches</a> pred f a :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)</span> <a href="src/Data.EvalRecord.html#line-865" class="link">Source</a> <a href="#t:MapMatches" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:MapMatches:Eval:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-EvalRecord.html">Data.EvalRecord</a></p> <div class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Eval" title="Fcf.Core">Eval</a> (<a href="Data-EvalRecord.html#t:MapMatches" title="Data.EvalRecord">MapMatches</a> pred f a :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) = <a href="Data-EvalRecord.html#t:ValueOnMatch" title="Data.EvalRecord">ValueOnMatch</a> (pred <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) a</div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a id="t:ValueOnMatch" class="def">ValueOnMatch</a> (cond :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) (b :: k) (a :: k) :: k <span class="keyword">where ...</span> <a href="src/Data.EvalRecord.html#ValueOnMatch" class="link">Source</a> <a href="#t:ValueOnMatch" class="selflink">#</a></p><div class="subs equations"><p class="caption">Equations</p><table><tr><td class="src"><a href="Data-EvalRecord.html#t:ValueOnMatch" title="Data.EvalRecord">ValueOnMatch</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a> (b :: k) (_1 :: k) = b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-EvalRecord.html#t:ValueOnMatch" title="Data.EvalRecord">ValueOnMatch</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a> (_1 :: k) (a :: k) = a</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:ApplyOnMatch" class="def">ApplyOnMatch</a> (cond :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) <a href="src/Data.EvalRecord.html#ApplyOnMatch" class="link">Source</a> <a href="#t:ApplyOnMatch" class="selflink">#</a></p><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src">applyOnMatch</p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:ApplyOnMatch">Instances</h4><details id="i:ApplyOnMatch" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:ApplyOnMatch:ApplyOnMatch:1"></span> <a href="Data-EvalRecord.html#t:ApplyOnMatch" title="Data.EvalRecord">ApplyOnMatch</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a></span> <a href="src/Data.EvalRecord.html#line-881" class="link">Source</a> <a href="#t:ApplyOnMatch" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:ApplyOnMatch:ApplyOnMatch:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-EvalRecord.html">Data.EvalRecord</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:applyOnMatch">applyOnMatch</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a> -&gt; (a -&gt; b) -&gt; a -&gt; <a href="Data-EvalRecord.html#t:ValueOnMatch" title="Data.EvalRecord">ValueOnMatch</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a> b a</p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:ApplyOnMatch:ApplyOnMatch:2"></span> <a href="Data-EvalRecord.html#t:ApplyOnMatch" title="Data.EvalRecord">ApplyOnMatch</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></span> <a href="src/Data.EvalRecord.html#line-877" class="link">Source</a> <a href="#t:ApplyOnMatch" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:ApplyOnMatch:ApplyOnMatch:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-EvalRecord.html">Data.EvalRecord</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:applyOnMatch">applyOnMatch</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a> -&gt; (a -&gt; b) -&gt; a -&gt; <a href="Data-EvalRecord.html#t:ValueOnMatch" title="Data.EvalRecord">ValueOnMatch</a> '<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a> b a</p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:mapMatching" class="def">mapMatching</a> :: <span class="keyword">forall</span> (pred :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) (f :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (g :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) rec. (<a href="Data-EvalRecord.html#t:FunctorRec" title="Data.EvalRecord">FunctorRec</a> rec, <a href="Data-EvalRecord.html#t:ConstraintsRec" title="Data.EvalRecord">ConstraintsRec</a> rec, <a href="Data-EvalRecord.html#t:AllRecF" title="Data.EvalRecord">AllRecF</a> <a href="Data-EvalRecord.html#t:ApplyOnMatch" title="Data.EvalRecord">ApplyOnMatch</a> (pred <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:-60--61--60-" title="Fcf.Combinators">&lt;=&lt;</a> f) rec) =&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> pred -&gt; (<span class="keyword">forall</span> a. <a href="Data-EvalRecord.html#t:Metadata" title="Data.EvalRecord">Metadata</a> a -&gt; (f <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; (g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:-60--61--60-" title="Fcf.Combinators">&lt;=&lt;</a> f) <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) -&gt; rec f -&gt; rec (<a href="Data-EvalRecord.html#t:MapMatches" title="Data.EvalRecord">MapMatches</a> pred g <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Combinators.html#t:-60--61--60-" title="Fcf.Combinators">&lt;=&lt;</a> f) <a href="src/Data.EvalRecord.html#mapMatching" class="link">Source</a> <a href="#v:mapMatching" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:applyPred" class="def">applyPred</a> :: <span class="keyword">forall</span> {k} (pred :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:Exp" title="Fcf.Core">Exp</a> k) a. <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> pred -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Proxy.html#t:Proxy" title="Data.Proxy">Proxy</a> (pred <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf-Core.html#t:-64--64-" title="Fcf.Core">@@</a> a) <a href="src/Data.EvalRecord.html#applyPred" class="link">Source</a> <a href="#v:applyPred" class="selflink">#</a></p></div><a href="#g:12" id="g:12"><h1>Reexports</h1></a><div class="top"><p class="src">module <a href="https://hackage.haskell.org/package/first-class-families-0.8.1.0/docs/Fcf.html">Fcf</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.28.0</p></div></body></html>